import{createQueryTester as t,$eq as s,$ne as i,$lt as e,$lte as n,$gt as r,$gte as o,$in as c,$nin as h,$all as l,$size as a,$regex as u,$elemMatch as f,$exists as d}from"sift";function p(t){return Array.isArray(t)?t:[t]}const y="__caslSubjectType__";function b(t,s){if(s)if(s.hasOwnProperty(y)){if(t!==s[y])throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${s[y]}`)}else Object.defineProperty(s,y,{value:t});return s}function $(t){if(!t)return"all";if("string"==typeof t)return t;if(t.hasOwnProperty(y))return t[y];const s="function"==typeof t?t:t.constructor;return s.modelName||s.name}const w=t=>t;function g(t){return"production"!==process.env.NODE_ENV&&function(t){if(t.manage)throw new Error('Cannot add alias for "manage" action because it is reserved');Object.keys(t).forEach(s=>{if(s===t[s]||Array.isArray(t[s])&&(-1!==t[s].indexOf(s)||-1!==t[s].indexOf("manage")))throw new Error(`Attempt to alias action to itself: ${s} -> ${t[s]}`)})}(t),s=>function(t,s){let i=p(s),e=0;for(;e<i.length;){const s=i[e++];t.hasOwnProperty(s)&&(i=i.concat(t[s]))}return i}(t,s)}class v{constructor(t,s){this.t=void 0,this.s=void 0,this.action=s.resolveAction(t.actions||t.action),this.subject=t.subject,this.inverted=!!t.inverted,this.conditions=t.conditions,this.reason=t.reason,this.fields=t.fields&&0!==t.fields.length?p(t.fields):void 0,"actions"in t&&console.warn("Rule `actions` field is deprecated. Use `action` field instead"),this.conditions&&s.conditionsMatcher&&(this.t=s.conditionsMatcher(this.conditions)),this.fields&&s.fieldMatcher&&(this.s=s.fieldMatcher(this.fields))}matchesConditions(t){return!this.t||(t&&"string"!=typeof t&&"function"!=typeof t?this.t(t):!this.inverted)}matchesField(t){return!this.s||(t?this.s(t):!this.inverted)}}class j{constructor(t){this.i=void 0,this.o=!1,this.h=!1,this.i=t,this.l=this.l.bind(this)}l({fields:t,inverted:s}){this.i=this.i&&!!s,this.h||!Array.isArray(t)||t.length||(this.h=!0),!this.o&&t&&t.length&&(this.o=!0)}u(t){if(this.i&&console.warn("Make sure your ability has direct rules, not only inverted ones. Otherwise `ability.can` will always return `false`."),this.h&&console.warn("[error in next major version]: There are rules with `fields` property being an empty array. This results in the same as not passing fields at all. Make sure to remove empty array or pass fields."),this.o&&!t.fieldMatcher)throw new Error('Field level restrictions are ignored because "fieldMatcher" option is not specified. Did you unintentionally used PureAbility instead of Ability?')}}class m extends class{constructor(t=[],s={}){this.o=!1,this.p=Object.create(null),this.$=Object.create(null),this.g=Object.create(null),this.v=[],this.j={conditionsMatcher:s.conditionsMatcher,fieldMatcher:s.fieldMatcher,resolveAction:s.resolveAction||w},Object.defineProperty(this,"detectSubjectType",{value:s.detectSubjectType||s.subjectName||$}),Object.defineProperty(this,"rules",{get:()=>this.v}),this.update(t)}update(t){const s={rules:t,ability:this,target:this};this.m("update",s),this.p=Object.create(null);const i=new j(t.length>0),e=this.O(t,i.l);return i.u(this.j),this.g=e,this.v=t,this.o=i.o,this.m("updated",s),this}O(t,s=w){const i=Object.create(null);for(let e=0;e<t.length;e++){s(t[e],e);const n=new v(t[e],this.j),r=t.length-e-1,o=p(n.action),c=p(n.subject);for(let t=0;t<c.length;t++){const s=this.detectSubjectType(c[t]);i[s]=i[s]||Object.create(null);for(let t=0;t<o.length;t++){const e=o[t];i[s][e]=i[s][e]||Object.create(null),i[s][e][r]=n}}}return i}possibleRulesFor(...t){const[s,i]=t,e=this.detectSubjectType(i),n=this.p,r=`${e}_${s}`;return n[r]||(n[r]=this.M(s,e)),n[r]}M(t,s){return("all"===s?[s]:[s,"all"]).reduce((s,i)=>{const e=this.g[i];return e?Object.assign(s,e[t],e.manage):s},[]).filter(Boolean)}rulesFor(...t){const[s,i,e]=t,n=this.possibleRulesFor(s,i);if(e&&"string"!=typeof e)throw new Error("The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details");return this.o?n.filter(t=>t.matchesField(e)):n}on(t,s){const i=this.$;let e=!0;return i[t]||(i[t]=[]),i[t].push(s),()=>{if(e){const n=i[t].indexOf(s);i[t].splice(n,1),e=!1}}}m(t,s){const i=this.$[t];i&&i.slice(0).forEach(t=>t(s))}}{can(...t){const s=this.relevantRuleFor(...t);return!!s&&!s.inverted}relevantRuleFor(...t){const s=this.rulesFor(...t),i=t[1];for(let t=0;t<s.length;t++)if(s[t].matchesConditions(i))return s[t];return null}cannot(...t){return!this.can(...t)}}const O={$eq:s,$ne:i,$lt:e,$lte:n,$gt:r,$gte:o,$in:c,$nin:h,$all:l,$size:a,$regex:u,$elemMatch:f,$exists:d};function x(s){const i={operations:Object.assign({},O,s)};return s=>t(s,i)}const E=x({}),M=/[-/\\^$+?.()|[\]{}]/g,_=/\.?\*+\.?/g,A=/\*+/,F=/\./g;function T(t,s,i){const e="*"===i[0]||"."===t[0]&&"."===t[t.length-1]?"+":"*",n=-1===t.indexOf("**")?"[^.]":".",r=t.replace(F,"\\$&").replace(A,n+e);return s+t.length===i.length?`(?:${r})?`:r}function R(t,s,i){return"."!==t||"*"!==i[s-1]&&"*"!==i[s+1]?"\\"+t:t}const C=t=>{let s;return i=>(void 0===s&&(s=t.every(t=>-1===t.indexOf("*"))?null:function(t){const s=t.map(t=>t.replace(M,R).replace(_,T)),i=s.length>1?`(?:${s.join("|")})`:s[0];return new RegExp(`^${i}$`)}(t)),null===s?-1!==t.indexOf(i):s.test(i))};class S extends m{constructor(t,s){super(t,Object.assign({conditionsMatcher:E,fieldMatcher:C},s))}}class k{constructor(t){this.rule=t}because(t){return this.rule.reason=t,this}}class z{constructor(t=m){this.rules=[],this._=t;this.can=this.can.bind(this),this.cannot=this.cannot.bind(this),this.build=this.build.bind(this)}can(t,s,i,e){const n={action:t};return s&&(n.subject=s,Array.isArray(i)||"string"==typeof i?n.fields=i:void 0!==i&&(n.conditions=i),void 0!==e&&(n.conditions=e)),this.rules.push(n),new k(n)}cannot(t,s,i,e){const n=this.can(t,s,i,e);return n.rule.inverted=!0,n}build(t){return new this._(this.rules,t)}}function D(t,s){let i,e;if("function"==typeof t)e=t,i={};else{if("function"!=typeof s)throw new Error("`defineAbility` expects to receive either options and dsl function or only dsl function");i=t,e=s}const n=new z(S),r=e(n.can,n.cannot);return r&&"function"==typeof r.then?r.then(()=>n.build(i)):n.build(i)}const U=t=>`Cannot execute "${t.action}" on "${t.subjectType}"`,q=function(t){this.message=t};q.prototype=Object.create(Error.prototype);class B extends q{static setDefaultMessage(t){this.A="string"==typeof t?()=>t:t}static from(t){return new this(t)}constructor(t){super(""),this.ability=void 0,this.field=void 0,this.ability=t,"function"==typeof Error.captureStackTrace&&(this.name="ForbiddenError",Error.captureStackTrace(this,this.constructor))}setMessage(t){return this.message=t,this}throwUnlessCan(...t){const s=this.ability.relevantRuleFor(...t);if(s&&!s.inverted)return;this.action=t[0],this.subject=t[1],this.subjectType=this.ability.detectSubjectType(t[1]),this.field=t[2];const i=s?s.reason:"";throw this.message=this.message||i||this.constructor.A(this),this}}B.A=U;export{S as Ability,z as AbilityBuilder,B as ForbiddenError,m as PureAbility,x as buildMongoQueryMatcher,g as createAliasResolver,D as defineAbility,$ as detectSubjectType,C as fieldPatternMatcher,U as getDefaultErrorMessage,E as mongoQueryMatcher,b as subject,p as wrapArray};
//# sourceMappingURL=index.js.map
