{"version":3,"file":"extra.js","sources":["../../src/utils.ts","../../src/extra.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport function detectSubjectType<T extends Subject>(subject?: T): string {\n  if (!subject) {\n    return 'all';\n  }\n\n  if (typeof subject === 'string') {\n    return subject;\n  }\n\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  const Type = typeof subject === 'function' ? subject : subject.constructor;\n  return (Type as SubjectClass).modelName || Type.name;\n}\n\nexport function expandActions(aliasMap: AliasesMap, rawActions: string | string[]) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = actions.concat(aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction assertAliasMap(aliasMap: AliasesMap) {\n  if (aliasMap.manage) {\n    throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  }\n\n  Object.keys(aliasMap).forEach((alias) => {\n    const hasError = alias === aliasMap[alias]\n      || Array.isArray(aliasMap[alias]) && (\n        aliasMap[alias].indexOf(alias) !== -1 || aliasMap[alias].indexOf('manage') !== -1\n      );\n\n    if (hasError) {\n      throw new Error(`Attempt to alias action to itself: ${alias} -> ${aliasMap[alias]}`);\n    }\n  });\n}\n\nexport const identity = <T>(x: T) => x;\nexport function createAliasResolver(aliasMap: AliasesMap) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertAliasMap(aliasMap);\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action);\n}\n","import { PureAbility, AnyAbility } from './PureAbility';\nimport { RuleOf, Generics } from './RuleIndex';\nimport { RawRule } from './RawRule';\nimport { Rule } from './Rule';\nimport { setByPath, wrapArray } from './utils';\nimport {\n  AbilityParameters,\n  AnyObject,\n  SubjectType,\n  AbilityTuple,\n  CanParameters,\n  Abilities\n} from './types';\n\nexport type RuleToQueryConverter<T extends AnyAbility> = (rule: RuleOf<T>) => object;\nexport interface AbilityQuery {\n  $or?: object[]\n  $and?: object[]\n}\n\ntype RulesToQueryRestArgs<T extends Abilities, ConvertRule> = AbilityParameters<\nT,\nT extends AbilityTuple\n  ? (action: T[0], subject: T[1], convert: ConvertRule) => 0\n  : never,\n(action: never, subject: never, convert: ConvertRule) => 0\n>;\n\nexport function rulesToQuery<T extends AnyAbility>(\n  ability: T,\n  ...args: RulesToQueryRestArgs<Generics<T>['abilities'], RuleToQueryConverter<T>>\n): AbilityQuery | null {\n  const [action, subject, convert] = args;\n  const query: AbilityQuery = {};\n  const rules = ability.rulesFor(action, subject) as RuleOf<T>[];\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    const op = rule.inverted ? '$and' : '$or';\n\n    if (!rule.conditions) {\n      if (rule.inverted) {\n        break;\n      } else {\n        delete query[op];\n        return query;\n      }\n    } else {\n      query[op] = query[op] || [];\n      query[op]!.push(convert(rule));\n    }\n  }\n\n  return query.$or ? query : null;\n}\n\nexport function rulesToFields<T extends PureAbility<any, AnyObject>>(\n  ability: T,\n  ...[action, subject]: CanParameters<Generics<T>['abilities'], false>\n): AnyObject {\n  return ability.rulesFor(action, subject)\n    .filter(rule => !rule.inverted && rule.conditions)\n    .reduce((values, rule) => {\n      const conditions = rule.conditions!;\n\n      return Object.keys(conditions).reduce((fields, fieldName) => {\n        const value = conditions[fieldName];\n\n        if (!value || (value as any).constructor !== Object) {\n          setByPath(fields, fieldName, value);\n        }\n\n        return fields;\n      }, values);\n    }, {} as AnyObject);\n}\n\nconst getRuleFields = (rule: RuleOf<AnyAbility>) => rule.fields;\n\nexport type GetRuleFields<R extends Rule<any, any>> = (rule: R) => string[] | undefined;\n\nexport interface PermittedFieldsOptions<T extends AnyAbility> {\n  fieldsFrom?: GetRuleFields<RuleOf<T>>\n}\n\nfunction deleteKey(this: Record<string, any>, key: string) {\n  delete this[key];\n}\n\nfunction setKey(this: Record<string, any>, key: string) {\n  this[key] = true;\n}\n\nexport function permittedFieldsOf<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['can']>[0],\n  subject: Parameters<T['can']>[1],\n  options: PermittedFieldsOptions<T> = {}\n): string[] {\n  const fieldsFrom = options.fieldsFrom || getRuleFields;\n  const uniqueFields = ability.possibleRulesFor(action, subject)\n    .filter(rule => rule.matchesConditions(subject))\n    .reverse()\n    .reduce((fields, rule) => {\n      const names = fieldsFrom(rule);\n\n      if (names) {\n        const toggle = rule.inverted ? deleteKey : setKey;\n        names.forEach(toggle, fields);\n      }\n\n      return fields;\n    }, {} as Record<string, true>);\n\n  return Object.keys(uniqueFields);\n}\n\nconst joinIfArray = (value: string | string[]) => Array.isArray(value) ? value.join(',') : value;\n\nexport type PackRule<T extends RawRule<any, any>> =\n  [string, string] |\n  [string, string, T['conditions']] |\n  [string, string, T['conditions'] | 0, 1] |\n  [string, string, T['conditions'] | 0, 1 | 0, string] |\n  [string, string, T['conditions'] | 0, 1 | 0, string | 0, string];\n\nexport type PackSubjectType<T extends SubjectType> = (type: T) => string;\n\nexport function packRules<T extends RawRule<any, any>>(\n  rules: T[],\n  packSubject?: PackSubjectType<T['subject']>\n): PackRule<T>[] {\n  return rules.map((rule) => { // eslint-disable-line\n    const packedRule: PackRule<T> = [\n      joinIfArray((rule as any).action || (rule as any).actions),\n      typeof packSubject === 'function'\n        ? wrapArray(rule.subject).map(packSubject).join(',')\n        : joinIfArray(rule.subject),\n      rule.conditions || 0,\n      rule.inverted ? 1 : 0,\n      rule.fields ? joinIfArray(rule.fields) : 0,\n      rule.reason || ''\n    ];\n\n    while (!packedRule[packedRule.length - 1]) packedRule.pop();\n\n    return packedRule;\n  });\n}\n\nexport type UnpackSubjectType<T extends SubjectType> = (type: string) => T;\n\nexport function unpackRules<T extends RawRule<any, any>>(\n  rules: PackRule<T>[],\n  unpackSubject?: UnpackSubjectType<T['subject']>\n): T[] {\n  return rules.map(([action, subject, conditions, inverted, fields, reason]) => {\n    const subjects = subject.split(',');\n    const rule = {\n      inverted: !!inverted,\n      action: action.split(','),\n      subject: typeof unpackSubject === 'function'\n        ? subjects.map(unpackSubject)\n        : subjects\n    } as T;\n\n    if (conditions) {\n      rule.conditions = conditions;\n    }\n\n    if (fields) {\n      rule.fields = fields.split(',');\n    }\n\n    if (reason) {\n      rule.reason = reason;\n    }\n\n    return rule;\n  });\n}\n"],"names":["setByPath","object","path","value","ref","lastKey","indexOf","keys","split","pop","reduce","res","prop","rulesToQuery","ability","args","action","subject","convert","query","rules","rulesFor","i","length","rule","op","inverted","conditions","push","$or","rulesToFields","filter","values","Object","fields","fieldName","constructor","getRuleFields","deleteKey","key","this","setKey","permittedFieldsOf","options","fieldsFrom","uniqueFields","possibleRulesFor","matchesConditions","reverse","names","toggle","forEach","joinIfArray","Array","isArray","join","packRules","packSubject","map","packedRule","actions","reason","unpackRules","unpackSubject","subjects"],"mappings":"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"}