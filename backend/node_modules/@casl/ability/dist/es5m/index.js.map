{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/Rule.ts","../../src/RulesAnalyzer.ts","../../src/PureAbility.ts","../../src/RuleIndex.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport function detectSubjectType<T extends Subject>(subject?: T): string {\n  if (!subject) {\n    return 'all';\n  }\n\n  if (typeof subject === 'string') {\n    return subject;\n  }\n\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  const Type = typeof subject === 'function' ? subject : subject.constructor;\n  return (Type as SubjectClass).modelName || Type.name;\n}\n\nexport function expandActions(aliasMap: AliasesMap, rawActions: string | string[]) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = actions.concat(aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction assertAliasMap(aliasMap: AliasesMap) {\n  if (aliasMap.manage) {\n    throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  }\n\n  Object.keys(aliasMap).forEach((alias) => {\n    const hasError = alias === aliasMap[alias]\n      || Array.isArray(aliasMap[alias]) && (\n        aliasMap[alias].indexOf(alias) !== -1 || aliasMap[alias].indexOf('manage') !== -1\n      );\n\n    if (hasError) {\n      throw new Error(`Attempt to alias action to itself: ${alias} -> ${aliasMap[alias]}`);\n    }\n  });\n}\n\nexport const identity = <T>(x: T) => x;\nexport function createAliasResolver(aliasMap: AliasesMap) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertAliasMap(aliasMap);\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action);\n}\n","import { wrapArray } from './utils';\nimport {\n  MatchConditions,\n  RuleOptions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize\n} from './types';\nimport { RawRule } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nexport class Rule<A extends Abilities, C> {\n  private readonly _matchConditions: MatchConditions | undefined;\n  private readonly _matchField: MatchField<string> | undefined;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n\n  constructor(rule: RawRule<ToAbilityTypes<A>, C>, options: RuleOptions<A, C>) {\n    this.action = options.resolveAction((rule as any).actions || (rule as any).action);\n    this.subject = rule.subject;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = !rule.fields || rule.fields.length === 0\n      ? undefined\n      : wrapArray(rule.fields);\n\n    if ('actions' in rule) {\n      // eslint-disable-next-line\n      console.warn('Rule `actions` field is deprecated. Use `action` field instead');\n    }\n\n    if (this.conditions && options.conditionsMatcher) {\n      this._matchConditions = options.conditionsMatcher(this.conditions);\n    }\n\n    if (this.fields && options.fieldMatcher) {\n      this._matchField = options.fieldMatcher(this.fields);\n    }\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this._matchConditions) {\n      return true;\n    }\n\n    if (!object || typeof object === 'string' || typeof object === 'function') {\n      return !this.inverted;\n    }\n\n    return this._matchConditions(object as object);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this._matchField) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    return this._matchField(field);\n  }\n}\n","import { RawRuleFrom } from './RawRule';\nimport { Abilities, RuleOptions } from './types';\n\nexport default class RulesAnalyzer<A extends Abilities, C> {\n  public _isAllInverted: boolean;\n  public _hasPerFieldRules: boolean = false;\n  public _hasRuleWithEmptyFields: boolean = false;\n\n  constructor(hasRules: boolean) {\n    this._isAllInverted = hasRules;\n    this._analyze = this._analyze.bind(this);\n  }\n\n  _analyze({ fields, inverted }: RawRuleFrom<A, C>) {\n    this._isAllInverted = this._isAllInverted && !!inverted;\n\n    if (!this._hasRuleWithEmptyFields && Array.isArray(fields) && !fields.length) {\n      this._hasRuleWithEmptyFields = true;\n    }\n\n    if (!this._hasPerFieldRules && fields && fields.length) {\n      this._hasPerFieldRules = true;\n    }\n  }\n\n  _validate(ruleOptions: RuleOptions<A, C>) {\n    if (this._isAllInverted) {\n      // eslint-disable-next-line\n      console.warn('Make sure your ability has direct rules, not only inverted ones. Otherwise `ability.can` will always return `false`.');\n    }\n\n    if (this._hasRuleWithEmptyFields) {\n      // eslint-disable-next-line\n      console.warn('[error in next major version]: There are rules with `fields` property being an empty array. This results in the same as not passing fields at all. Make sure to remove empty array or pass fields.');\n    }\n\n    if (this._hasPerFieldRules && !ruleOptions.fieldMatcher) {\n      throw new Error('Field level restrictions are ignored because \"fieldMatcher\" option is not specified. Did you unintentionally used PureAbility instead of Ability?');\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, RawRuleOf } from './RuleIndex';\nimport { Abilities, CanParameters } from './types';\n\nexport type AbilityOptions<A extends Abilities, Conditions> = RuleIndexOptions<A, Conditions>;\nexport type AnyAbility = PureAbility<any, any>;\nexport type AbilityOptionsOf<T extends AnyAbility> = RuleIndexOptionsOf<T>;\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\ninterface AbilityEvent<A extends Abilities = Abilities, Conditions = unknown> {\n  /** @deprecated use \"target\" property instead */\n  ability: this['target']\n  target: PureAbility<A, Conditions>\n}\n\nexport class PureAbility<\n  A extends Abilities = Abilities,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions, AbilityEvent<A, Conditions>> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>) {\n    const rules = this.rulesFor(...args);\n    const subject = args[1];\n\n    for (let i = 0; i < rules.length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import { Rule } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  DetectSubjectType,\n  ResolveAction,\n  CanParameters,\n  Abilities,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n  RuleOptions,\n} from './types';\nimport { wrapArray, detectSubjectType, identity } from './utils';\nimport RulesAnalyzer from './RulesAnalyzer';\n\ntype AnyRuleIndex = RuleIndex<any, any, any>;\n\nexport interface RuleIndexOptions<A extends Abilities, Conditions> {\n  /** @deprecated use \"detectSubjectType\" option instead */\n  subjectName?: this['detectSubjectType']\n  detectSubjectType?: DetectSubjectType<Normalize<A>[1]>\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction?: ResolveAction<Normalize<A>[0]>\n}\n\nexport type Generics<T extends AnyRuleIndex> = T extends AnyRuleIndex\n  ? { abilities: T['za'], conditions: T['zc'] }\n  : never;\n\nexport type RuleOf<T extends AnyRuleIndex> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends AnyRuleIndex> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends AnyRuleIndex> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport interface UpdateEvent<T extends AnyRuleIndex> {\n  rules: RawRuleOf<T>[]\n}\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<T extends AnyRuleIndex, Event extends {} = {}> = {\n  [K in keyof EventsMap<T, Event>]: EventHandler<EventsMap<T, Event>[K]>[]\n};\n\ninterface EventsMap<T extends AnyRuleIndex, Event extends {} = {}> {\n  update: UpdateEvent<T> & Event\n  updated: UpdateEvent<T> & Event\n}\n\ninterface IndexTree<A extends Abilities, C> {\n  [subject: string]: {\n    [action: string]: {\n      [priority: number]: Rule<A, C>\n    }\n  }\n}\n\ntype RuleIterator<A extends Abilities, C> = (rule: RawRuleFrom<A, C>, index: number) => void;\n\nexport type Unsubscribe = () => void;\n\nexport class RuleIndex<A extends Abilities, Conditions, BaseEvent extends {} = {}> {\n  private _hasPerFieldRules: boolean = false;\n  private _mergedRules: Record<string, Rule<A, Conditions>[]> = Object.create(null);\n  private _events: Events<this, BaseEvent> = Object.create(null);\n  private _indexedRules: IndexTree<A, Conditions> = Object.create(null);\n  private _rules: this['rules'] = [];\n  readonly rules!: RawRuleFrom<A, Conditions>[];\n  readonly _ruleOptions!: RuleOptions<A, Conditions>;\n  readonly detectSubjectType!: DetectSubjectType<Normalize<A>[1]>;\n  /** @private hacky property to track Abilities type */\n  readonly za!: A;\n  /** @private hacky property to track Conditions type */\n  readonly zc!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    Object.defineProperty(this, 'detectSubjectType', {\n      value: options.detectSubjectType || options.subjectName || detectSubjectType\n    });\n    Object.defineProperty(this, 'rules', { get: () => this._rules });\n    this.update(rules);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): this {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this> & BaseEvent;\n\n    this._emit('update', event);\n    this._mergedRules = Object.create(null);\n\n    const analyser = new RulesAnalyzer<A, Conditions>(rules.length > 0);\n    const indexedRules = this._buildIndexFor(rules, analyser._analyze);\n\n    analyser._validate(this._ruleOptions);\n    this._indexedRules = indexedRules;\n    this._rules = rules;\n    this._hasPerFieldRules = analyser._hasPerFieldRules;\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(\n    rawRules: RawRuleFrom<A, Conditions>[],\n    iterator: RuleIterator<A, Conditions> = identity\n  ) {\n    const indexedRules: IndexTree<A, Conditions> = Object.create(null);\n\n    for (let i = 0; i < rawRules.length; i++) {\n      iterator(rawRules[i], i);\n      const rule = new Rule(rawRules[i], this._ruleOptions);\n      const priority = rawRules.length - i - 1;\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subject = this.detectSubjectType(subjects[k]);\n        indexedRules[subject] = indexedRules[subject] || Object.create(null);\n\n        for (let j = 0; j < actions.length; j++) {\n          const action = actions[j];\n          indexedRules[subject][action] = indexedRules[subject][action] || Object.create(null);\n          indexedRules[subject][action][priority] = rule;\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: CanParameters<A, false>) {\n    const [action, subject] = args;\n    const subjectName = this.detectSubjectType(subject);\n    const mergedRules = this._mergedRules;\n    const key = `${subjectName}_${action}`;\n\n    if (!mergedRules[key]) {\n      mergedRules[key] = this._mergeRulesFor(action, subjectName);\n    }\n\n    return mergedRules[key];\n  }\n\n  private _mergeRulesFor(action: string, subjectName: string) {\n    const subjects = subjectName === 'all' ? [subjectName] : [subjectName, 'all'];\n    const mergedRules = subjects.reduce((rules, subjectType) => {\n      const subjectRules = this._indexedRules[subjectType];\n\n      if (!subjectRules) {\n        return rules;\n      }\n\n      return Object.assign(rules, subjectRules[action], subjectRules.manage);\n    }, []);\n\n    // TODO: think whether there is a better way to prioritize rules\n    // or convert sparse array to regular one\n    return mergedRules.filter(Boolean);\n  }\n\n  rulesFor(...args: CanParameters<A>) {\n    const [action, subject, field] = args;\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subject);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this, BaseEvent>>(\n    event: T,\n    handler: EventHandler<EventsMap<this, BaseEvent>[T]>\n  ): Unsubscribe {\n    const events = this._events;\n    let isAttached = true;\n\n    if (!events[event]) {\n      events[event] = [];\n    }\n\n    events[event].push(handler);\n\n    return () => {\n      if (isAttached) {\n        const index = events[event].indexOf(handler);\n        events[event].splice(index, 1);\n        isAttached = false;\n      }\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this, BaseEvent>>(\n    eventName: T,\n    event: EventsMap<this, BaseEvent>[T]\n  ) {\n    const handlers = this._events[eventName];\n\n    if (handlers) {\n      handlers.slice(0).forEach(handler => handler(event));\n    }\n  }\n}\n","import {\n  createQueryTester as sift,\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $elemMatch,\n  $exists\n} from 'sift';\nimport { ConditionsMatcher as Matcher } from '../types';\n\nconst defaultOperations = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $elemMatch,\n  $exists,\n};\n\ntype RegExpOptions<T> = { $regex: T, $options?: string };\ntype Primitive = Record<PropertyKey, any> | string | number | null | boolean | undefined;\nexport type MongoQueryOperators = {\n  $eq?: any,\n  $ne?: any,\n  $lt?: string | number | Date,\n  $lte?: string | number | Date,\n  $gt?: string | number | Date,\n  $gte?: string | number | Date,\n  $in?: any[],\n  $nin?: any[],\n  $all?: any[],\n  /** checks by array length */\n  $size?: number,\n  $regex?: RegExp | RegExpOptions<string> | RegExpOptions<RegExp>,\n  /** checks the shape of array item */\n  $elemMatch?: {\n    [k in Exclude<keyof MongoQueryOperators, '$elemMatch'>]?: MongoQueryOperators[k]\n  },\n  /** checks that property exists */\n  $exists?: boolean\n};\n\nexport type MongoQuery<AdditionalOperators = never> =\n  Record<PropertyKey, MongoQueryOperators | Primitive | AdditionalOperators>;\nexport function buildMongoQueryMatcher<T extends object>(\n  operations: Record<keyof T, any>\n): Matcher<MongoQuery | T> {\n  const options = { operations: { ...defaultOperations, ...operations } };\n  return conditions => sift(conditions as any, options);\n}\nexport const mongoQueryMatcher = buildMongoQueryMatcher({});\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { RawRuleFrom } from './RawRule';\nimport { fieldPatternMatcher } from './matchers/field';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery<any> = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport type AnyMongoAbility = Ability<any, MongoQuery>;\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass, PureAbility } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  AbilityTypes,\n  ToAbilityTypes,\n  AbilityParameters\n} from './types';\nimport { RawRule } from './RawRule';\n\nclass RuleBuilder<T extends RawRule<any, any>> {\n  public rule!: T;\n\n  constructor(rule: T) {\n    this.rule = rule;\n  }\n\n  because(reason: string): this {\n    this.rule.reason = reason;\n    return this;\n  }\n}\n\ntype CanFunction<T extends AbilityTypes, C, WithFields = true> = T extends AbilityTuple\n  ? WithFields extends true\n    // eslint-disable-next-line max-len\n    ? (action: T[0] | T[0][], subject: E<T[1]> | E<T[1]>[], fields?: string | string[], conditions?: C) => 0\n    : (action: T[0] | T[0][], subject: E<T[1]> | E<T[1]>[], conditions?: C) => 0\n  : never;\n\nexport type BuilderCanParameters<T extends AnyAbility, WithFields extends boolean = false> =\n  AbilityParameters<\n  Generics<T>['abilities'],\n  CanFunction<ToAbilityTypes<Generics<T>['abilities']>, Generics<T>['conditions'], WithFields>,\n  (action: Generics<T>['abilities'] | Generics<T>['abilities'][]) => 0\n  >;\n\nexport class AbilityBuilder<T extends AnyAbility = PureAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AbilityClass<T>;\n\n  constructor(AbilityType: AbilityClass<T> = PureAbility as AbilityClass<T>) {\n    this._AbilityType = AbilityType;\n    const self = this as any;\n    self.can = self.can.bind(self);\n    self.cannot = self.cannot.bind(self);\n    self.build = self.build.bind(self);\n  }\n\n  can(...args: BuilderCanParameters<T>): RuleBuilder<RawRuleOf<T>>\n  can(...args: BuilderCanParameters<T, true>): RuleBuilder<RawRuleOf<T>>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<RawRuleOf<T>> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot(...args: BuilderCanParameters<T>): RuleBuilder<RawRuleOf<T>>\n  cannot(...args: BuilderCanParameters<T, true>): RuleBuilder<RawRuleOf<T>>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<RawRuleOf<T>> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder.rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>): T {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype AsyncDSL<T extends AnyMongoAbility> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => Promise<void>;\ntype DSL<T extends AnyMongoAbility> = (...args: Parameters<AsyncDSL<T>>) => void;\n\nexport function defineAbility<T extends AnyMongoAbility = Ability>(\n  dsl: AsyncDSL<T>\n): Promise<T>;\nexport function defineAbility<T extends AnyMongoAbility = Ability>(\n  params: AbilityOptionsOf<T>,\n  dsl: AsyncDSL<T>\n): Promise<T>;\nexport function defineAbility<T extends AnyMongoAbility = Ability>(\n  dsl: DSL<T>\n): T;\nexport function defineAbility<T extends AnyMongoAbility = Ability>(\n  params: AbilityOptionsOf<T>,\n  dsl: DSL<T>\n): T;\nexport function defineAbility<T extends AnyMongoAbility = Ability>(\n  params: AbilityOptionsOf<T> | DSL<T> | AsyncDSL<T>,\n  dsl?: DSL<T> | AsyncDSL<T>\n): T | Promise<T> {\n  let options: AbilityOptionsOf<T>;\n  let define: DSL<T> | AsyncDSL<T>;\n\n  if (typeof params === 'function') {\n    define = params;\n    options = {};\n  } else if (typeof dsl === 'function') {\n    options = params;\n    define = dsl;\n  } else {\n    throw new Error('`defineAbility` expects to receive either options and dsl function or only dsl function');\n  }\n\n  const builder = new AbilityBuilder<T>(Ability as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  return result && typeof result.then === 'function'\n    ? result.then(() => builder.build(options))\n    : builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<T extends AnyAbility>(ability: T) {\n    return new this(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = this.ability.detectSubjectType(args[1]);\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n"],"names":["wrapArray","value","Array","isArray","TYPE_FIELD","setSubjectType","type","object","hasOwnProperty","Error","Object","defineProperty","detectSubjectType","subject","Type","constructor","modelName","name","identity","x","createAliasResolver","aliasMap","process","env","NODE_ENV","manage","keys","forEach","alias","indexOf","assertAliasMap","action","rawActions","actions","i","length","concat","expandActions","Rule","rule","options","_matchConditions","_matchField","resolveAction","inverted","conditions","reason","fields","undefined","console","warn","this","conditionsMatcher","fieldMatcher","matchesConditions","matchesField","field","RulesAnalyzer","hasRules","_isAllInverted","_hasPerFieldRules","_hasRuleWithEmptyFields","_analyze","bind","_validate","ruleOptions","PureAbility","can","relevantRuleFor","rules","rulesFor","cannot","_mergedRules","create","_events","_indexedRules","_rules","_ruleOptions","subjectName","get","_this","update","event","ability","target","_emit","analyser","indexedRules","_buildIndexFor","rawRules","iterator","priority","subjects","k","j","possibleRulesFor","args","mergedRules","key","_mergeRulesFor","reduce","subjectType","subjectRules","_this2","assign","filter","Boolean","on","handler","events","isAttached","push","index","splice","eventName","handlers","slice","defaultOperations","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$elemMatch","$exists","buildMongoQueryMatcher","operations","sift","mongoQueryMatcher","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","string","quantifier","matcher","pattern","replace","escapeRegexp","fieldPatternMatcher","every","f","patterns","map","join","RegExp","createPattern","test","Ability","_PureAbility","RuleBuilder","because","AbilityBuilder","AbilityType","_AbilityType","build","conditionsOrFields","builder","defineAbility","params","dsl","define","result","then","getDefaultErrorMessage","error","NativeError","message","prototype","ForbiddenError","captureStackTrace","setDefaultMessage","messageOrFn","_defaultErrorMessage","from","setMessage","throwUnlessCan"],"mappings":"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"}