{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport function detectSubjectType<T extends Subject>(subject?: T): string {\n  if (!subject) {\n    return 'all';\n  }\n\n  if (typeof subject === 'string') {\n    return subject;\n  }\n\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  const Type = typeof subject === 'function' ? subject : subject.constructor;\n  return (Type as SubjectClass).modelName || Type.name;\n}\n\nexport function expandActions(aliasMap: AliasesMap, rawActions: string | string[]) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = actions.concat(aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction assertAliasMap(aliasMap: AliasesMap) {\n  if (aliasMap.manage) {\n    throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  }\n\n  Object.keys(aliasMap).forEach((alias) => {\n    const hasError = alias === aliasMap[alias]\n      || Array.isArray(aliasMap[alias]) && (\n        aliasMap[alias].indexOf(alias) !== -1 || aliasMap[alias].indexOf('manage') !== -1\n      );\n\n    if (hasError) {\n      throw new Error(`Attempt to alias action to itself: ${alias} -> ${aliasMap[alias]}`);\n    }\n  });\n}\n\nexport const identity = <T>(x: T) => x;\nexport function createAliasResolver(aliasMap: AliasesMap) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertAliasMap(aliasMap);\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n","import { wrapArray } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate<A extends Abilities, C>(rule: RawRuleFrom<A, C>, options: RuleOptions<A, C>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\ntype ResolveAction<T> = (action: T | T[]) => T | T[];\nexport interface RuleOptions<A extends Abilities, Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction: ResolveAction<Normalize<A>[0]>\n}\n\nexport class Rule<A extends Abilities, C> {\n  private __matchConditions: MatchConditions | undefined;\n  private __matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<A, C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<A, C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private get _matchConditions() {\n    if (this.conditions && !this.__matchConditions) {\n      this.__matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this.__matchConditions;\n  }\n\n  private get _matchField() {\n    if (this.fields && !this.__matchField) {\n      this.__matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this.__matchField;\n  }\n\n  get ast() {\n    return this._matchConditions ? this._matchConditions.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this._matchConditions) {\n      return true;\n    }\n\n    if (!object || typeof object === 'string' || typeof object === 'function') {\n      return !this.inverted;\n    }\n\n    return this._matchConditions(object as object);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this._matchField) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    return this._matchField(field);\n  }\n}\n","export class LinkedItem<T> {\n  public next: LinkedItem<T> | null = null;\n\n  constructor(\n    public readonly value: T,\n    public prev: LinkedItem<T> | null = null\n  ) {\n    if (prev) {\n      prev.next = this;\n    }\n  }\n\n  destroy() {\n    const { next, prev } = this;\n\n    if (next) {\n      next.prev = prev;\n    }\n\n    if (prev) {\n      prev.next = next;\n    }\n\n    this.next = this.prev = null; // eslint-disable-line\n  }\n}\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport { CanParameters, Abilities, Normalize, Subject, SubjectType } from './types';\nimport { wrapArray, detectSubjectType, identity, mergePrioritized, getOrDefault } from './utils';\nimport { LinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<A, C>> {\n  detectSubjectType?(subject?: Normalize<A>[1]): string\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport type Generics<T extends WithGenerics> = {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n};\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport interface UpdateEvent<T extends WithGenerics> {\n  rules: RawRuleOf<T>[]\n}\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  Event extends {} = {},\n  K extends keyof EventsMap<T, Event> = keyof EventsMap<T, Event>\n> = Map<K, {\n  last: LinkedItem<EventHandler<EventsMap<T, Event>[K]>> | null,\n  destroy: Array<Unsubscribe> | null,\n  emits: boolean\n}>;\n\ninterface EventsMap<T extends WithGenerics, Event extends {} = {}> {\n  update: UpdateEvent<T> & Event\n  updated: UpdateEvent<T> & Event\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst defaultEventEntry = () => ({ emits: false, last: null, destroy: null });\n\nexport class RuleIndex<A extends Abilities, Conditions, BaseEvent extends {} = {}> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this, BaseEvent> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<A, Conditions>;\n  readonly detectSubjectType!: Exclude<RuleIndexOptions<A, Conditions>['detectSubjectType'], undefined>;\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this.detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this> & BaseEvent;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject);\n      this._analyze(rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectType = this.detectSubjectType(subjects[k]);\n        const subjectRules = getOrDefault(indexedRules, subjectType, defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  private _analyze(rule: Rule<A, Conditions>) {\n    if (!this._hasPerFieldRules && rule.fields) {\n      this._hasPerFieldRules = true;\n    }\n  }\n\n  possibleRulesFor(...[action, subject]: CanParameters<A, false>) {\n    const subjectType = this.detectSubjectType(subject);\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const manageRules = action !== 'manage' && subjectRules.has('manage')\n      ? subjectRules.get('manage')!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, manageRules);\n\n    if (subjectType !== 'all') {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, 'all'));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: CanParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subject);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this, BaseEvent>>(\n    event: T,\n    handler: EventHandler<EventsMap<this, BaseEvent>[T]>\n  ): Unsubscribe {\n    const details = getOrDefault(this._events, event, defaultEventEntry);\n    const item = new LinkedItem(handler, details.last);\n    details.last = item;\n    const destroy = () => {\n      if (details.emits) {\n        details.destroy = details.destroy || [];\n        details.destroy.push(destroy);\n        return;\n      }\n\n      if (!item.next && !item.prev && details.last === item) {\n        details.last = null;\n      } else {\n        item.destroy();\n      }\n    };\n\n    return destroy;\n  }\n\n  private _emit<T extends keyof EventsMap<this, BaseEvent>>(\n    name: T,\n    payload: EventsMap<this, BaseEvent>[T]\n  ) {\n    const details = this._events.get(name);\n\n    if (!details) {\n      return;\n    }\n\n    try {\n      details.emits = true;\n      let item = details.last;\n      while (item !== null) {\n        item.value(payload);\n        item = item.prev;\n      }\n    } finally {\n      details.emits = false;\n      if (details.destroy) {\n        details.destroy.forEach(destroy => destroy());\n      }\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public } from './RuleIndex';\nimport { Abilities, CanParameters } from './types';\n\nexport type AbilityOptions<A extends Abilities, Conditions> = RuleIndexOptions<A, Conditions>;\nexport type AnyAbility = Public<PureAbility<any, any>>;\nexport type AbilityOptionsOf<T extends AnyAbility> = RuleIndexOptionsOf<T>;\nexport type AbilityClass<T extends AnyAbility> = new (...args: any[]) => T;\n\ninterface AbilityEvent<A extends Abilities = Abilities, Conditions = unknown> {\n  /** @deprecated use \"target\" property instead */\n  ability: this['target']\n  target: PureAbility<A, Conditions>\n}\n\nexport class PureAbility<\n  A extends Abilities = Abilities,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions, AbilityEvent<A, Conditions>> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>) {\n    const rules = this.rulesFor(...args);\n    const subject = args[1];\n\n    for (let i = 0; i < rules.length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.join('').indexOf('*') === -1\n        ? null\n        : createPattern(fields);\n    }\n\n    if (pattern === null || field.indexOf('*') !== -1) {\n      return fields.indexOf(field) !== -1;\n    }\n\n    return pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { Public } from './RuleIndex';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { RawRuleFrom } from './RawRule';\nimport { fieldPatternMatcher } from './matchers/field';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport type AnyMongoAbility = Public<Ability<any, MongoQuery>>;\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  SubjectClass,\n  AnyObject,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype ExtractWithDefault<T, U, D = never> = T extends U ? T : D;\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends SubjectClass\n  ? InstanceType<S>\n  : ExtractWithDefault<Normalize<Generics<T>['abilities']>[1], TaggedInterface<Extract<S, string>>, AnyObject>;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<\n  U extends AbilityClass<AnyAbility>,\n  T extends InstanceType<U> = InstanceType<U>\n> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: U;\n\n  constructor(AbilityType: U) {\n    this._AbilityType = AbilityType;\n    const self = this as any;\n    self.can = self.can.bind(self);\n    self.cannot = self.cannot.bind(self);\n    self.build = self.build.bind(self);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options) as T;\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<AbilityClass<T>>['can'],\n  cannot: AbilityBuilder<AbilityClass<T>>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<T extends AnyAbility>(ability: T) {\n    return new this(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = this.ability.detectSubjectType(args[1]);\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n"],"names":["wrapArray","value","Array","isArray","TYPE_FIELD","detectSubjectType","subject","hasOwnProperty","Type","constructor","modelName","name","identity","x","copyArrayTo","dest","target","start","i","length","push","mergePrioritized","array","anotherArray","j","merged","priority","getOrDefault","map","key","defaultValue","get","set","Rule","rule","options","__matchConditions","__matchField","fields","Error","fieldMatcher","conditions","conditionsMatcher","validate","action","resolveAction","inverted","reason","undefined","_options","this","_matchConditions","ast","matchesConditions","object","matchesField","field","_matchField","LinkedItem","prev","next","destroy","defaultActionEntry","rules","defaultSubjectEntry","Map","defaultEventEntry","emits","last","PureAbility","_hasPerFieldRules","_events","_ruleOptions","_rules","_indexedRules","_buildIndexFor","update","event","ability","_emit","rawRules","indexedRules","actions","subjects","_analyze","k","subjectRules","possibleRulesFor","subjectType","actionRules","manageRules","has","rulesFor","filter","on","handler","details","item","payload","forEach","can","args","relevantRuleFor","cannot","defaultInstructions","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$options","$elemMatch","$exists","defaultInterpreters","eq","ne","lt","lte","gt","gte","in","within","nin","all","size","regex","elemMatch","exists","mongoQueryMatcher","createFactory","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","index","string","quantifier","matcher","indexOf","pattern","replace","escapeRegexp","fieldPatternMatcher","join","patterns","RegExp","createPattern","test","Ability","RuleBuilder","_rule","because","AbilityBuilder","AbilityType","_AbilityType","bind","build","conditionsOrFields","builder","getDefaultErrorMessage","error","NativeError","message","prototype","Object","create","ForbiddenError","messageOrFn","_defaultErrorMessage","captureStackTrace","setMessage","throwUnlessCan","instructions","interpreters","aliasMap","process","env","NODE_ENV","manage","keys","alias","assertAliasMap","rawActions","concat","expandActions","define","result","then","type","defineProperty"],"mappings":"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"}