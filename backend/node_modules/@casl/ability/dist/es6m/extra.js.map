{"version":3,"file":"extra.js","sources":["../../src/extra.ts","../../src/utils.ts"],"sourcesContent":["import { PureAbility, AnyAbility } from './PureAbility';\nimport { RuleOf, Generics } from './RuleIndex';\nimport { RawRule } from './RawRule';\nimport { Rule } from './Rule';\nimport { setByPath, wrapArray } from './utils';\nimport {\n  AbilityParameters,\n  AnyObject,\n  SubjectType,\n  AbilityTuple,\n  CanParameters,\n  Abilities\n} from './types';\n\nexport type RuleToQueryConverter<T extends AnyAbility> = (rule: RuleOf<T>) => object;\nexport interface AbilityQuery {\n  $or?: object[]\n  $and?: object[]\n}\n\ntype RulesToQueryRestArgs<T extends Abilities, ConvertRule> = AbilityParameters<\nT,\nT extends AbilityTuple\n  ? (action: T[0], subject: T[1], convert: ConvertRule) => 0\n  : never,\n(action: never, subject: never, convert: ConvertRule) => 0\n>;\n\nexport function rulesToQuery<T extends AnyAbility>(\n  ability: T,\n  ...args: RulesToQueryRestArgs<Generics<T>['abilities'], RuleToQueryConverter<T>>\n): AbilityQuery | null {\n  const [action, subject, convert] = args;\n  const query: AbilityQuery = {};\n  const rules = ability.rulesFor(action, subject) as RuleOf<T>[];\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    const op = rule.inverted ? '$and' : '$or';\n\n    if (!rule.conditions) {\n      if (rule.inverted) {\n        break;\n      } else {\n        delete query[op];\n        return query;\n      }\n    } else {\n      query[op] = query[op] || [];\n      query[op]!.push(convert(rule));\n    }\n  }\n\n  return query.$or ? query : null;\n}\n\nexport function rulesToFields<T extends PureAbility<any, AnyObject>>(\n  ability: T,\n  ...[action, subject]: CanParameters<Generics<T>['abilities'], false>\n): AnyObject {\n  return ability.rulesFor(action, subject)\n    .filter(rule => !rule.inverted && rule.conditions)\n    .reduce((values, rule) => {\n      const conditions = rule.conditions!;\n\n      return Object.keys(conditions).reduce((fields, fieldName) => {\n        const value = conditions[fieldName];\n\n        if (!value || (value as any).constructor !== Object) {\n          setByPath(fields, fieldName, value);\n        }\n\n        return fields;\n      }, values);\n    }, {} as AnyObject);\n}\n\nconst getRuleFields = (rule: RuleOf<AnyAbility>) => rule.fields;\n\nexport type GetRuleFields<R extends Rule<any, any>> = (rule: R) => string[] | undefined;\n\nexport interface PermittedFieldsOptions<T extends AnyAbility> {\n  fieldsFrom?: GetRuleFields<RuleOf<T>>\n}\n\nfunction deleteKey(this: Record<string, any>, key: string) {\n  delete this[key];\n}\n\nfunction setKey(this: Record<string, any>, key: string) {\n  this[key] = true;\n}\n\nexport function permittedFieldsOf<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['can']>[0],\n  subject: Parameters<T['can']>[1],\n  options: PermittedFieldsOptions<T> = {}\n): string[] {\n  const fieldsFrom = options.fieldsFrom || getRuleFields;\n  const uniqueFields = ability.possibleRulesFor(action, subject)\n    .filter(rule => rule.matchesConditions(subject))\n    .reverse()\n    .reduce((fields, rule) => {\n      const names = fieldsFrom(rule);\n\n      if (names) {\n        const toggle = rule.inverted ? deleteKey : setKey;\n        names.forEach(toggle, fields);\n      }\n\n      return fields;\n    }, {} as Record<string, true>);\n\n  return Object.keys(uniqueFields);\n}\n\nconst joinIfArray = (value: string | string[]) => Array.isArray(value) ? value.join(',') : value;\n\nexport type PackRule<T extends RawRule<any, any>> =\n  [string, string] |\n  [string, string, T['conditions']] |\n  [string, string, T['conditions'] | 0, 1] |\n  [string, string, T['conditions'] | 0, 1 | 0, string] |\n  [string, string, T['conditions'] | 0, 1 | 0, string | 0, string];\n\nexport type PackSubjectType<T extends SubjectType> = (type: T) => string;\n\nexport function packRules<T extends RawRule<any, any>>(\n  rules: T[],\n  packSubject?: PackSubjectType<T['subject']>\n): PackRule<T>[] {\n  return rules.map((rule) => { // eslint-disable-line\n    const packedRule: PackRule<T> = [\n      joinIfArray((rule as any).action || (rule as any).actions),\n      typeof packSubject === 'function'\n        ? wrapArray(rule.subject).map(packSubject).join(',')\n        : joinIfArray(rule.subject),\n      rule.conditions || 0,\n      rule.inverted ? 1 : 0,\n      rule.fields ? joinIfArray(rule.fields) : 0,\n      rule.reason || ''\n    ];\n\n    while (!packedRule[packedRule.length - 1]) packedRule.pop();\n\n    return packedRule;\n  });\n}\n\nexport type UnpackSubjectType<T extends SubjectType> = (type: string) => T;\n\nexport function unpackRules<T extends RawRule<any, any>>(\n  rules: PackRule<T>[],\n  unpackSubject?: UnpackSubjectType<T['subject']>\n): T[] {\n  return rules.map(([action, subject, conditions, inverted, fields, reason]) => {\n    const subjects = subject.split(',');\n    const rule = {\n      inverted: !!inverted,\n      action: action.split(','),\n      subject: typeof unpackSubject === 'function'\n        ? subjects.map(unpackSubject)\n        : subjects\n    } as T;\n\n    if (conditions) {\n      rule.conditions = conditions;\n    }\n\n    if (fields) {\n      rule.fields = fields.split(',');\n    }\n\n    if (reason) {\n      rule.reason = reason;\n    }\n\n    return rule;\n  });\n}\n","import { AnyObject, Subject, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport function detectSubjectType<T extends Subject>(subject?: T): string {\n  if (!subject) {\n    return 'all';\n  }\n\n  if (typeof subject === 'string') {\n    return subject;\n  }\n\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  const Type = typeof subject === 'function' ? subject : subject.constructor;\n  return (Type as SubjectClass).modelName || Type.name;\n}\n\nexport function expandActions(aliasMap: AliasesMap, rawActions: string | string[]) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = actions.concat(aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction assertAliasMap(aliasMap: AliasesMap) {\n  if (aliasMap.manage) {\n    throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  }\n\n  Object.keys(aliasMap).forEach((alias) => {\n    const hasError = alias === aliasMap[alias]\n      || Array.isArray(aliasMap[alias]) && (\n        aliasMap[alias].indexOf(alias) !== -1 || aliasMap[alias].indexOf('manage') !== -1\n      );\n\n    if (hasError) {\n      throw new Error(`Attempt to alias action to itself: ${alias} -> ${aliasMap[alias]}`);\n    }\n  });\n}\n\nexport const identity = <T>(x: T) => x;\nexport function createAliasResolver(aliasMap: AliasesMap) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertAliasMap(aliasMap);\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action);\n}\n"],"names":["rulesToQuery","ability","args","action","subject","convert","query","rules","rulesFor","i","length","rule","op","inverted","conditions","push","$or","rulesToFields","filter","reduce","values","Object","keys","fields","fieldName","value","constructor","object","path","ref","lastKey","indexOf","split","pop","res","prop","setByPath","getRuleFields","deleteKey","key","this","setKey","permittedFieldsOf","options","fieldsFrom","uniqueFields","possibleRulesFor","matchesConditions","reverse","names","toggle","forEach","joinIfArray","Array","isArray","join","packRules","packSubject","map","packedRule","actions","reason","unpackRules","unpackSubject","subjects"],"mappings":"AA4BO,SAASA,EACdC,KACGC,SAEIC,EAAQC,EAASC,GAAWH,EAC7BI,EAAsB,GACtBC,EAAQN,EAAQO,SAASL,EAAQC,OAElC,IAAIK,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAAK,OAC/BE,EAAOJ,EAAME,GACbG,EAAKD,EAAKE,SAAW,OAAS,UAE/BF,EAAKG,WAAY,IAChBH,EAAKE,6BAGAP,EAAMM,GACNN,EAGTA,EAAMM,GAAMN,EAAMM,IAAO,GACzBN,EAAMM,GAAKG,KAAKV,EAAQM,WAIrBL,EAAMU,IAAMV,EAAQ,KAGtB,SAASW,EACdhB,MACIE,EAAQC,WAELH,EAAQO,SAASL,EAAQC,GAC7Bc,OAAOP,IAASA,EAAKE,UAAYF,EAAKG,YACtCK,OAAO,CAACC,EAAQT,WACTG,EAAaH,EAAKG,kBAEjBO,OAAOC,KAAKR,GAAYK,OAAO,CAACI,EAAQC,WACvCC,EAAQX,EAAWU,UAEpBC,GAAUA,EAAcC,cAAgBL,QC9D9C,SAAmBM,EAAmBC,EAAcH,OACrDI,EAAMF,EACNG,EAAUF,MAEa,IAAvBA,EAAKG,QAAQ,KAAa,OACtBT,EAAOM,EAAKI,MAAM,KAExBF,EAAUR,EAAKW,MACfJ,EAAMP,EAAKH,OAAO,CAACe,EAAKC,KACtBD,EAAIC,GAAQD,EAAIC,IAAS,GAClBD,EAAIC,IACVR,GAGLE,EAAIC,GAAWL,EDiDPW,CAAUb,EAAQC,EAAWC,GAGxBF,GACNH,IACF,IAGP,MAAMiB,EAAiB1B,GAA6BA,EAAKY,OAQzD,SAASe,EAAqCC,UACrCC,KAAKD,GAGd,SAASE,EAAkCF,QACpCA,IAAO,EAGP,SAASG,EACdzC,EACAE,EACAC,EACAuC,EAAqC,UAE/BC,EAAaD,EAAQC,YAAcP,EACnCQ,EAAe5C,EAAQ6C,iBAAiB3C,EAAQC,GACnDc,OAAOP,GAAQA,EAAKoC,kBAAkB3C,IACtC4C,UACA7B,OAAO,CAACI,EAAQZ,WACTsC,EAAQL,EAAWjC,MAErBsC,EAAO,OACHC,EAASvC,EAAKE,SAAWyB,EAAYG,EAC3CQ,EAAME,QAAQD,EAAQ3B,UAGjBA,GACN,WAEEF,OAAOC,KAAKuB,GAGrB,MAAMO,EAAe3B,GAA6B4B,MAAMC,QAAQ7B,GAASA,EAAM8B,KAAK,KAAO9B,EAWpF,SAAS+B,EACdjD,EACAkD,UAEOlD,EAAMmD,IAAK/C,UACVgD,EAA0B,CAC9BP,EAAazC,EAAaR,QAAWQ,EAAaiD,SAC3B,mBAAhBH,GCrIgBhC,EDsITd,EAAKP,QCrIhBiD,MAAMC,QAAQ7B,GAASA,EAAQ,CAACA,IDqIPiC,IAAID,GAAaF,KAAK,KAC9CH,EAAYzC,EAAKP,SACrBO,EAAKG,YAAc,EACnBH,EAAKE,SAAW,EAAI,EACpBF,EAAKY,OAAS6B,EAAYzC,EAAKY,QAAU,EACzCZ,EAAKkD,QAAU,QC3Id,IAAsBpC,GD8IjBkC,EAAWA,EAAWjD,OAAS,IAAIiD,EAAW1B,aAE/C0B,IAMJ,SAASG,EACdvD,EACAwD,UAEOxD,EAAMmD,IAAI,EAAEvD,EAAQC,EAASU,EAAYD,EAAUU,EAAQsC,YAC1DG,EAAW5D,EAAQ4B,MAAM,KACzBrB,EAAO,CACXE,WAAYA,EACZV,OAAQA,EAAO6B,MAAM,KACrB5B,QAAkC,mBAAlB2D,EACZC,EAASN,IAAIK,GACbC,UAGFlD,IACFH,EAAKG,WAAaA,GAGhBS,IACFZ,EAAKY,OAASA,EAAOS,MAAM,MAGzB6B,IACFlD,EAAKkD,OAASA,GAGTlD"}