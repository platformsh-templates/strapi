class t{constructor(t,e){this.operator=t,this.value=e}}class e extends t{constructor(t,e){if(!Array.isArray(e))throw new Error(`"${t}" operator expects to receive an array of conditions`);super(t,e)}}const r="__itself__";class n{constructor(t,e,r){this.operator=t,this.value=r,this.field=e}}const o=new t("__null__",null);function i(t,e){const r=t[e];if("function"!=typeof r)throw new Error(`Unable to interpret "${e}" condition. Did you forget to register interpreter for it?`);return r}function c(t,r){return r instanceof e&&r.operator===t}function s(t,r){return 1===r.length?r[0]:new e(t,function t(e,r,n){const o=n||[];for(let n=0,i=r.length;n<i;n++){const i=r[n];c(e,i)?t(e,i.value,o):o.push(i)}return o}(t,r))}const u=t=>s("and",t),a=t=>s("or",t);function f(t){if(!t||t&&t.constructor!==Object)return!1;for(const e in t)if(t.hasOwnProperty(e)&&"$"===e[0])return!0;return!1}function l(t,e){if(!Array.isArray(e))throw new Error(`"${t.name}" expects value to be an array`)}function p(t,e){if(l(t,e),!e.length)throw new Error(`"${t.name}" expects to have at least one element in array`)}const d=t=>(e,r)=>{if(typeof r!==t)throw new Error(`"${e.name}" expects value to be a "${t}"`)},h={type:"compound",validate:p,parse(t,e,{parse:r}){const n=e.map(t=>r(t));return s(t.name,n)}},w=h,y={type:"compound",validate:p},$={type:"field",validate(t,e){if(!e||!(e instanceof RegExp||e.constructor===Object))throw new Error(`"${t.name}" expects to receive either regular expression or object of field operators`)},parse(t,r,o){const i=r instanceof RegExp?new n("regex",o.field,r):o.parse(r,o);return new e(t.name,[i])}},b={type:"field",validate(t,e){if(!e||e.constructor!==Object)throw new Error(`"${t.name}" expects to receive an object with nested query or field level operators`)},parse(t,e,{parse:o,field:i}){const c=f(e)?o(e,{field:r}):o(e);return new n(t.name,i,c)}},v={type:"field",validate:d("number")},g={type:"field",validate:l},j=g,m=g,x={type:"field",validate(t,e){if(!Array.isArray(e)||2!==e.length)throw new Error(`"${t.name}" expects an array with 2 numeric elements`)}},E={type:"field",validate:d("boolean")},O={type:"field",validate:function(t,e){if(!("string"==typeof e||"number"==typeof e||e instanceof Date))throw new Error(`"${t.name}" expects value to be comparable (i.e., string, number or date)`)}},_=O,A=_,q=_,U={type:"field"},k=U,R={type:"field",validate(t,e){if(!(e instanceof RegExp)&&"string"!=typeof e)throw new Error(`"${t.name}" expects value to be a regular expression or a string that represents regular expression`)},parse(t,e,r){const o="string"==typeof e?new RegExp(e,r.query.$options||""):e;return new n(t.name,r.field,o)}},S={type:"field",parse:()=>o},D={type:"document",validate:d("function")};var N=Object.freeze({__proto__:null,$and:h,$or:w,$nor:y,$not:$,$elemMatch:b,$size:v,$in:g,$nin:j,$all:m,$mod:x,$exists:E,$gte:O,$gt:_,$lt:A,$lte:q,$eq:U,$ne:k,$regex:R,$options:S,$where:D});const z={compound(t,r,n){const o=(Array.isArray(r)?r:[r]).map(t=>n.parse(t));return new e(t.name,o)},field:(t,e,r)=>new n(t.name,r.field,e),document:(e,r)=>new t(e.name,r)};function M(t,e,r){return"function"==typeof t.validate&&t.validate(t,e),(t.parse||z[t.type])(t,e,r)}class P{constructor(t){this.t=void 0,this.o=void 0,this.t=Object.keys(t).reduce((e,r)=>(e[r]=Object.assign({},t[r],{name:r.slice(1)}),e),{}),this.parse=this.parse.bind(this),this.o={field:"",query:{},parse:this.parse}}setParse(t){this.parse=t,this.o.parse=t}i(t,e,r,n){const o=this.t[e];if(!o)throw new Error(`Unsupported operator "${e}"`);if("field"!==o.type)throw new Error(`Unexpected ${o.type} operator "${e}" at field level`);return this.o.field=t,this.o.query=n,M(o,r,this.o)}s(t,e){const r=[],n=Object.keys(e);for(let i=0,c=n.length;i<c;i++){const c=n[i];if("$"!==c[0])throw new Error(`Field query for "${t}" may contain only operators or a plain object as a value`);const s=this.i(t,c,e[c],e);s!==o&&r.push(s)}return r}parse(t,e){if(e&&e.field)return u(this.s(e.field,t));const r=t,n={query:r,parse:this.parse},o=[],i=Object.keys(r);for(let t=0,e=i.length;t<e;t++){const e=i[t],c=r[e],s="$"===e[0],u=this.t[e];if(s){if(!u)throw new Error(`Unsupported operator "${e}"`);if("document"!==u.type&&"compound"!==u.type)throw new Error(`Unknown top level operator "${e}"`);o.push(M(u,c,n))}else f(c)?o.push(...this.s(e,c)):o.push(this.i(e,"$eq",c,r))}return u(o)}}const F=N;function J(t,e,r){for(let n=0,o=t.length;n<o;n++)if(r(t[n],e))return!0;return!1}function T(t,e){return Array.isArray(t)&&Number.isNaN(Number(e))}function B(t,e,r){return T(t,e)?t.reduce((t,n)=>{const o=r(n,e);return void 0!==o?t.concat(o):t},[]):r(t,e)}function C(t){return(e,r,n)=>{const o=n.get(r,e.field);return Array.isArray(o)?o.some(r=>t(e,r,n)):t(e,o,n)}}const G=(t,e)=>t[e];function H(t,e,r){const n=e.lastIndexOf(".");return-1===n?[t,e]:[r(t,e.slice(0,n)),e.slice(n+1)]}function I(t,e,n=G){if(e===r)return t;if(!t)throw new Error(`Unable to get field "${e}" out of ${String(t)}.`);return function(t,e,r){if(-1===e.indexOf("."))return B(t,e,r);const n=e.split(".");let o=t;for(let t=0,e=n.length;t<e;t++)if(o=B(o,n[t],r),!o||"object"!=typeof o)return o;return o}(t,e,n)}function K(t,e){return t===e?0:t>e?1:-1}function L(t,e={}){const r=e.compare||K;return function(t,e){const r=e;let n;switch(r?r.numberOfArguments:0){case 1:n=e=>i(t,e.operator)(e,o);break;case 3:n=(e,r,n)=>i(t,e.operator)(e,r,n,o);break;default:n=(e,r)=>i(t,e.operator)(e,r,o)}const o=Object.assign({},r,{interpret:n});return o.interpret}(t,Object.assign({get:I,compare:K,equal:(t,e)=>0===r(t,e)},e))}const Q=(t,e,{interpret:r})=>t.value.some(t=>r(t,e)),V=(t,e,{equal:r,get:n})=>{const o=n(e,t.field);return Array.isArray(o)&&!Array.isArray(t.value)?J(o,t.value,r):r(o,t.value)},W=C((t,e,r)=>{const n=r.compare(e,t.value);return 0===n||-1===n}),X=C((t,e,r)=>-1===r.compare(e,t.value)),Y=C((t,e,r)=>1===r.compare(e,t.value)),Z=C((t,e,r)=>{const n=r.compare(e,t.value);return 0===n||1===n}),tt=C((t,e)=>e%t.value[0]===t.value[1]),et=C((t,e)=>t.value.test(e)),rt=C((t,e,{equal:r})=>J(t.value,e,r));var nt=Object.freeze({__proto__:null,or:Q,nor:(t,e,r)=>!Q(t,e,r),and:(t,e,{interpret:r})=>t.value.every(t=>r(t,e)),not:(t,e,{interpret:r})=>!r(t.value[0],e),eq:V,ne:(t,e,r)=>!V(t,e,r),lte:W,lt:X,gt:Y,gte:Z,exists:(t,e,{get:n})=>{if(t.field===r)return void 0!==e;const[o,i]=H(e,t.field,n),c=e=>!!e&&e.hasOwnProperty(i)===t.value;return T(o,i)?o.some(c):c(o)},mod:tt,size:(t,e,{get:n})=>{const[o,i]=H(e,t.field,n),c=e=>{const r=n(e,i);return Array.isArray(r)&&r.length===t.value};return t.field!==r&&T(o,i)?o.some(c):c(o)},regex:et,within:rt,nin:(t,e,r)=>!rt(t,e,r),all:(t,e,{equal:r,get:n})=>{const o=n(e,t.field);return Array.isArray(o)&&t.value.every(t=>J(o,t,r))},elemMatch:(t,e,{interpret:r,get:n})=>{const o=n(e,t.field);return Array.isArray(o)&&o.some(e=>r(t.value,e))},where:(t,e)=>t.value.call(e)});const ot=Object.assign({},nt,{in:rt});L(ot);function it(t){return t instanceof Date?t.getTime():t&&"function"==typeof t.toJSON?t.toJSON():t}const ct=(t,e)=>K(it(t),it(e));function st(t,e,n){const o=new P(t),i=L(e,Object.assign({compare:ct},n));if(n&&n.forPrimitives){const t={field:r},e=o.parse;o.setParse(r=>e(r,t))}return function(t,e){return(r,...n)=>{const o=t(r,...n),i=e.bind(null,o);return i.ast=o,i}}(o.parse,i)}st(F,ot),st(["$and","$or"].reduce((t,e)=>(t[e]=Object.assign({},t[e],{type:"field"}),t),Object.assign({},F,{$nor:Object.assign({},F.$nor,{type:"field",parse:z.compound})})),ot,{forPrimitives:!0});function ut(t,e,r,n){const o=Object.create(null),i=t.rulesFor(e,r);for(let t=0;t<i.length;t++){const e=i[t],r=e.inverted?"$and":"$or";if(!e.conditions){if(e.inverted)break;return delete o[r],o}o[r]=o[r]||[],o[r].push(n(e))}return o.$or?o:null}function at(t){if(!t.ast)throw new Error(`Ability rule "${JSON.stringify(t)}" does not have "ast" property. So, cannot be used to generate AST`);return t.ast}function ft(t,e,r){const n=ut(t,e,r,at);return null===n?null:n.$and?(n.$or&&n.$and.push(a(n.$or)),u(n.$and)):n.$or?a(n.$or):u([])}function lt(t,e,r){return t.rulesFor(e,r).filter(t=>!t.inverted&&t.conditions).reduce((t,e)=>{const r=e.conditions;return Object.keys(r).reduce((t,e)=>{const n=r[e];return n&&n.constructor===Object||function(t,e,r){let n=t,o=e;if(-1!==e.indexOf(".")){const r=e.split(".");o=r.pop(),n=r.reduce((t,e)=>(t[e]=t[e]||{},t[e]),t)}n[o]=r}(t,e,n),t},t)},{})}const pt=t=>t.fields;function dt(t){delete this[t]}function ht(t){this[t]=!0}function wt(t,e,r,n={}){const o=n.fieldsFrom||pt,i=t.possibleRulesFor(e,r).filter(t=>t.matchesConditions(r)).reverse().reduce((t,e)=>{const r=o(e);if(r){const n=e.inverted?dt:ht;r.forEach(n,t)}return t},{});return Object.keys(i)}const yt=t=>Array.isArray(t)?t.join(","):t;function $t(t,e){return t.map(t=>{const r=[yt(t.action||t.actions),"function"==typeof e?(n=t.subject,Array.isArray(n)?n:[n]).map(e).join(","):yt(t.subject),t.conditions||0,t.inverted?1:0,t.fields?yt(t.fields):0,t.reason||""];for(var n;!r[r.length-1];)r.pop();return r})}function bt(t,e){return t.map(([t,r,n,o,i,c])=>{const s=r.split(","),u={inverted:!!o,action:t.split(","),subject:"function"==typeof e?s.map(e):s};return n&&(u.conditions=n),i&&(u.fields=i.split(",")),c&&(u.reason=c),u})}export{$t as packRules,wt as permittedFieldsOf,ft as rulesToAST,lt as rulesToFields,ut as rulesToQuery,bt as unpackRules};
//# sourceMappingURL=extra.mjs.map
