import{createFactory as t,$eq as s,$ne as e,$lt as i,$lte as n,$gt as r,$gte as o,$in as c,$nin as h,$all as u,$size as l,$regex as a,$elemMatch as f,$exists as d,eq as p,ne as b,lt as y,lte as $,gt as g,gte as w,within as j,nin as m,all as v,size as O,regex as x,elemMatch as E,exists as M}from"@ucast/mongo2js";function _(t){return Array.isArray(t)?t:[t]}const A="__caslSubjectType__";function F(t,s){if(s)if(s.hasOwnProperty(A)){if(t!==s[A])throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${s[A]}`)}else Object.defineProperty(s,A,{value:t});return s}function R(t){if(!t)return"all";if("string"==typeof t)return t;if(t.hasOwnProperty(A))return t[A];const s="function"==typeof t?t:t.constructor;return s.modelName||s.name}const C=t=>t;function T(t){return"production"!==process.env.NODE_ENV&&function(t){if(t.manage)throw new Error('Cannot add alias for "manage" action because it is reserved');Object.keys(t).forEach(s=>{if(s===t[s]||Array.isArray(t[s])&&(-1!==t[s].indexOf(s)||-1!==t[s].indexOf("manage")))throw new Error(`Attempt to alias action to itself: ${s} -> ${t[s]}`)})}(t),s=>function(t,s){let e=_(s),i=0;for(;i<e.length;){const s=e[i++];t.hasOwnProperty(s)&&(e=e.concat(t[s]))}return e}(t,s)}class z{constructor(t,s){this.t=void 0,this.s=void 0,this.ast=void 0,function(t,s){if(Array.isArray(t.fields)&&!t.fields.length)throw new Error("`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa");if(t.fields&&!s.fieldMatcher)throw new Error('You need to pass "fieldMatcher" option in order to restrict access by fields');if(t.conditions&&!s.conditionsMatcher)throw new Error('You need to pass "conditionsMatcher" option in order to restrict access by conditions')}(t,s),this.action=s.resolveAction(t.action),this.subject=t.subject,this.inverted=!!t.inverted,this.conditions=t.conditions,this.reason=t.reason,this.fields=t.fields?_(t.fields):void 0,this.conditions&&(this.t=s.conditionsMatcher(this.conditions),this.ast=this.t.ast),this.fields&&(this.s=s.fieldMatcher(this.fields))}matchesConditions(t){return!this.t||(t&&"string"!=typeof t&&"function"!=typeof t?this.t(t):!this.inverted)}matchesField(t){return!this.s||(t?this.s(t):!this.inverted)}}class S extends class{constructor(t=[],s={}){this.i=!1,this.o=Object.create(null),this.h=Object.create(null),this.u=Object.create(null),this.l=[],this.p={conditionsMatcher:s.conditionsMatcher,fieldMatcher:s.fieldMatcher,resolveAction:s.resolveAction||C},Object.defineProperty(this,"detectSubjectType",{value:s.detectSubjectType||R}),Object.defineProperty(this,"rules",{get:()=>this.l}),this.update(t)}update(t){const s={rules:t,ability:this,target:this};return this.$("update",s),this.o=Object.create(null),this.u=this.g(t),this.l=t,this.$("updated",s),this}g(t){const s=Object.create(null);for(let e=0;e<t.length;e++){const i=new z(t[e],this.p),n=t.length-e-1,r=_(i.action),o=_(i.subject);this.j(i);for(let t=0;t<o.length;t++){const e=this.detectSubjectType(o[t]);s[e]=s[e]||Object.create(null);for(let t=0;t<r.length;t++){const o=r[t];s[e][o]=s[e][o]||Object.create(null),s[e][o][n]=i}}}return s}j(t){!this.i&&t.fields&&(this.i=!0)}possibleRulesFor(...t){const[s,e]=t,i=this.detectSubjectType(e),n=this.o,r=`${i}_${s}`;return n[r]||(n[r]=this.m(s,i)),n[r]}m(t,s){return("all"===s?[s]:[s,"all"]).reduce((s,e)=>{const i=this.u[e];return i?Object.assign(s,i[t],i.manage):s},[]).filter(Boolean)}rulesFor(...t){const[s,e,i]=t,n=this.possibleRulesFor(s,e);if(i&&"string"!=typeof i)throw new Error("The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details");return this.i?n.filter(t=>t.matchesField(i)):n}on(t,s){const e=this.h;let i=!0;return e[t]||(e[t]=[]),e[t].push(s),()=>{if(i){const n=e[t].indexOf(s);e[t].splice(n,1),i=!1}}}$(t,s){const e=this.h[t];e&&e.slice(0).forEach(t=>t(s))}}{can(...t){const s=this.relevantRuleFor(...t);return!!s&&!s.inverted}relevantRuleFor(...t){const s=this.rulesFor(...t),e=t[1];for(let t=0;t<s.length;t++)if(s[t].matchesConditions(e))return s[t];return null}cannot(...t){return!this.can(...t)}}const q={$eq:s,$ne:e,$lt:i,$lte:n,$gt:r,$gte:o,$in:c,$nin:h,$all:u,$size:l,$regex:a,$elemMatch:f,$exists:d},Y={eq:p,ne:b,lt:y,lte:$,gt:g,gte:w,in:j,nin:m,all:v,size:O,regex:x,elemMatch:E,exists:M},B=(s,e,i)=>t(Object.assign({},q,s),Object.assign({},Y,e),i),D=B(),I=/[-/\\^$+?.()|[\]{}]/g,L=/\.?\*+\.?/g,U=/\*+/,k=/\./g;function G(t,s,e){const i="*"===e[0]||"."===t[0]&&"."===t[t.length-1]?"+":"*",n=-1===t.indexOf("**")?"[^.]":".",r=t.replace(k,"\\$&").replace(U,n+i);return s+t.length===e.length?`(?:${r})?`:r}function H(t,s,e){return"."!==t||"*"!==e[s-1]&&"*"!==e[s+1]?"\\"+t:t}const J=t=>{let s;return e=>(void 0===s&&(s=-1===t.join("").indexOf("*")?null:function(t){const s=t.map(t=>t.replace(I,H).replace(L,G)),e=s.length>1?`(?:${s.join("|")})`:s[0];return new RegExp(`^${e}$`)}(t)),null===s||-1!==e.indexOf("*")?-1!==t.indexOf(e):s.test(e))};class K extends S{constructor(t,s){super(t,Object.assign({conditionsMatcher:D,fieldMatcher:J},s))}}class N{constructor(t){this.v=t}because(t){return this.v.reason=t,this}}class P{constructor(t=S){this.rules=[],this.O=t;this.can=this.can.bind(this),this.cannot=this.cannot.bind(this),this.build=this.build.bind(this)}can(t,s,e,i){const n={action:t};return s&&(n.subject=s,Array.isArray(e)||"string"==typeof e?n.fields=e:void 0!==e&&(n.conditions=e),void 0!==i&&(n.conditions=i)),this.rules.push(n),new N(n)}cannot(t,s,e,i){const n=this.can(t,s,e,i);return n.v.inverted=!0,n}build(t){return new this.O(this.rules,t)}}function Q(t,s){let e,i;if("function"==typeof t)i=t,e={};else{if("function"!=typeof s)throw new Error("`defineAbility` expects to receive either options and dsl function or only dsl function");e=t,i=s}const n=new P(K),r=i(n.can,n.cannot);return r&&"function"==typeof r.then?r.then(()=>n.build(e)):n.build(e)}const V=t=>`Cannot execute "${t.action}" on "${t.subjectType}"`,W=function(t){this.message=t};W.prototype=Object.create(Error.prototype);class X extends W{static setDefaultMessage(t){this.M="string"==typeof t?()=>t:t}static from(t){return new this(t)}constructor(t){super(""),this.ability=void 0,this.field=void 0,this.ability=t,"function"==typeof Error.captureStackTrace&&(this.name="ForbiddenError",Error.captureStackTrace(this,this.constructor))}setMessage(t){return this.message=t,this}throwUnlessCan(...t){const s=this.ability.relevantRuleFor(...t);if(s&&!s.inverted)return;this.action=t[0],this.subject=t[1],this.subjectType=this.ability.detectSubjectType(t[1]),this.field=t[2];const e=s?s.reason:"";throw this.message=this.message||e||this.constructor.M(this),this}}X.M=V;export{K as Ability,P as AbilityBuilder,X as ForbiddenError,S as PureAbility,B as buildMongoQueryMatcher,T as createAliasResolver,Q as defineAbility,R as detectSubjectType,J as fieldPatternMatcher,V as getDefaultErrorMessage,D as mongoQueryMatcher,F as subject,_ as wrapArray};
//# sourceMappingURL=index.js.map
