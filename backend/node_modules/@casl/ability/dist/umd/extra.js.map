{"version":3,"file":"extra.js","sources":["../../src/utils.ts","../../src/extra.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport function detectSubjectType<T extends Subject>(subject?: T): string {\n  if (!subject) {\n    return 'all';\n  }\n\n  if (typeof subject === 'string') {\n    return subject;\n  }\n\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  const Type = typeof subject === 'function' ? subject : subject.constructor;\n  return (Type as SubjectClass).modelName || Type.name;\n}\n\nexport function expandActions(aliasMap: AliasesMap, rawActions: string | string[]) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = actions.concat(aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction assertAliasMap(aliasMap: AliasesMap) {\n  if (aliasMap.manage) {\n    throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  }\n\n  Object.keys(aliasMap).forEach((alias) => {\n    const hasError = alias === aliasMap[alias]\n      || Array.isArray(aliasMap[alias]) && (\n        aliasMap[alias].indexOf(alias) !== -1 || aliasMap[alias].indexOf('manage') !== -1\n      );\n\n    if (hasError) {\n      throw new Error(`Attempt to alias action to itself: ${alias} -> ${aliasMap[alias]}`);\n    }\n  });\n}\n\nexport const identity = <T>(x: T) => x;\nexport function createAliasResolver(aliasMap: AliasesMap) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertAliasMap(aliasMap);\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action);\n}\n","import { PureAbility, AnyAbility } from './PureAbility';\nimport { RuleOf, Generics } from './RuleIndex';\nimport { RawRule } from './RawRule';\nimport { Rule } from './Rule';\nimport { setByPath, wrapArray } from './utils';\nimport {\n  AbilityParameters,\n  AnyObject,\n  SubjectType,\n  AbilityTuple,\n  CanParameters,\n  Abilities\n} from './types';\n\nexport type RuleToQueryConverter<T extends AnyAbility> = (rule: RuleOf<T>) => object;\nexport interface AbilityQuery {\n  $or?: object[]\n  $and?: object[]\n}\n\ntype RulesToQueryRestArgs<T extends Abilities, ConvertRule> = AbilityParameters<\nT,\nT extends AbilityTuple\n  ? (action: T[0], subject: T[1], convert: ConvertRule) => 0\n  : never,\n(action: never, subject: never, convert: ConvertRule) => 0\n>;\n\nexport function rulesToQuery<T extends AnyAbility>(\n  ability: T,\n  ...args: RulesToQueryRestArgs<Generics<T>['abilities'], RuleToQueryConverter<T>>\n): AbilityQuery | null {\n  const [action, subject, convert] = args;\n  const query: AbilityQuery = {};\n  const rules = ability.rulesFor(action, subject) as RuleOf<T>[];\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    const op = rule.inverted ? '$and' : '$or';\n\n    if (!rule.conditions) {\n      if (rule.inverted) {\n        break;\n      } else {\n        delete query[op];\n        return query;\n      }\n    } else {\n      query[op] = query[op] || [];\n      query[op]!.push(convert(rule));\n    }\n  }\n\n  return query.$or ? query : null;\n}\n\nexport function rulesToFields<T extends PureAbility<any, AnyObject>>(\n  ability: T,\n  ...[action, subject]: CanParameters<Generics<T>['abilities'], false>\n): AnyObject {\n  return ability.rulesFor(action, subject)\n    .filter(rule => !rule.inverted && rule.conditions)\n    .reduce((values, rule) => {\n      const conditions = rule.conditions!;\n\n      return Object.keys(conditions).reduce((fields, fieldName) => {\n        const value = conditions[fieldName];\n\n        if (!value || (value as any).constructor !== Object) {\n          setByPath(fields, fieldName, value);\n        }\n\n        return fields;\n      }, values);\n    }, {} as AnyObject);\n}\n\nconst getRuleFields = (rule: RuleOf<AnyAbility>) => rule.fields;\n\nexport type GetRuleFields<R extends Rule<any, any>> = (rule: R) => string[] | undefined;\n\nexport interface PermittedFieldsOptions<T extends AnyAbility> {\n  fieldsFrom?: GetRuleFields<RuleOf<T>>\n}\n\nfunction deleteKey(this: Record<string, any>, key: string) {\n  delete this[key];\n}\n\nfunction setKey(this: Record<string, any>, key: string) {\n  this[key] = true;\n}\n\nexport function permittedFieldsOf<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['can']>[0],\n  subject: Parameters<T['can']>[1],\n  options: PermittedFieldsOptions<T> = {}\n): string[] {\n  const fieldsFrom = options.fieldsFrom || getRuleFields;\n  const uniqueFields = ability.possibleRulesFor(action, subject)\n    .filter(rule => rule.matchesConditions(subject))\n    .reverse()\n    .reduce((fields, rule) => {\n      const names = fieldsFrom(rule);\n\n      if (names) {\n        const toggle = rule.inverted ? deleteKey : setKey;\n        names.forEach(toggle, fields);\n      }\n\n      return fields;\n    }, {} as Record<string, true>);\n\n  return Object.keys(uniqueFields);\n}\n\nconst joinIfArray = (value: string | string[]) => Array.isArray(value) ? value.join(',') : value;\n\nexport type PackRule<T extends RawRule<any, any>> =\n  [string, string] |\n  [string, string, T['conditions']] |\n  [string, string, T['conditions'] | 0, 1] |\n  [string, string, T['conditions'] | 0, 1 | 0, string] |\n  [string, string, T['conditions'] | 0, 1 | 0, string | 0, string];\n\nexport type PackSubjectType<T extends SubjectType> = (type: T) => string;\n\nexport function packRules<T extends RawRule<any, any>>(\n  rules: T[],\n  packSubject?: PackSubjectType<T['subject']>\n): PackRule<T>[] {\n  return rules.map((rule) => { // eslint-disable-line\n    const packedRule: PackRule<T> = [\n      joinIfArray((rule as any).action || (rule as any).actions),\n      typeof packSubject === 'function'\n        ? wrapArray(rule.subject).map(packSubject).join(',')\n        : joinIfArray(rule.subject),\n      rule.conditions || 0,\n      rule.inverted ? 1 : 0,\n      rule.fields ? joinIfArray(rule.fields) : 0,\n      rule.reason || ''\n    ];\n\n    while (!packedRule[packedRule.length - 1]) packedRule.pop();\n\n    return packedRule;\n  });\n}\n\nexport type UnpackSubjectType<T extends SubjectType> = (type: string) => T;\n\nexport function unpackRules<T extends RawRule<any, any>>(\n  rules: PackRule<T>[],\n  unpackSubject?: UnpackSubjectType<T['subject']>\n): T[] {\n  return rules.map(([action, subject, conditions, inverted, fields, reason]) => {\n    const subjects = subject.split(',');\n    const rule = {\n      inverted: !!inverted,\n      action: action.split(','),\n      subject: typeof unpackSubject === 'function'\n        ? subjects.map(unpackSubject)\n        : subjects\n    } as T;\n\n    if (conditions) {\n      rule.conditions = conditions;\n    }\n\n    if (fields) {\n      rule.fields = fields.split(',');\n    }\n\n    if (reason) {\n      rule.reason = reason;\n    }\n\n    return rule;\n  });\n}\n"],"names":["setByPath","object","path","value","ref","lastKey","indexOf","keys","split","pop","reduce","res","prop","getRuleFields","rule","fields","deleteKey","key","this","setKey","joinIfArray","Array","isArray","join","rules","packSubject","map","packedRule","action","actions","subject","conditions","inverted","reason","length","ability","options","fieldsFrom","uniqueFields","possibleRulesFor","filter","matchesConditions","reverse","names","toggle","forEach","Object","rulesFor","values","fieldName","constructor","args","convert","query","i","op","push","$or","unpackSubject","subjects"],"mappings":"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"}